//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { environment } from '@env/environment';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import {
  of,
  switchMap,
  Observable,
  throwError as _observableThrow,
  of as _observableOf
} from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export abstract class ClientBase {
  transformResult(
    url_: string,
    response_: any,
    processResult: (r: HttpResponseBase) => Observable<any>
  ): Observable<any> {
    return processResult(response_).pipe(
      switchMap(t => {
        return of(t.data);
      })
    );
  }

  getBaseUrl(url: string): string {
    return environment.API_BASE_URL;
  }
}

@Injectable({
    providedIn: 'root'
})
export class AccountClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    /**
     * 登录
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginModel | undefined): Observable<LoginResult> {
        let url_ = this.baseUrl + "/api/Account/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processLogin(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processLogin(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResult>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoginResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class BatchClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    /**
     * 获取质量保证书
     * @param batchId (optional) 
     * @return Success
     */
    getProductExcel(batchId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/batch/GetProductExcel?";
        if (batchId === null)
            throw new Error("The parameter 'batchId' cannot be null.");
        else if (batchId !== undefined)
            url_ += "batchId=" + encodeURIComponent("" + batchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processGetProductExcel(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetProductExcel(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetProductExcel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param printIdOrBatchNo (optional) 
     * @return Success
     */
    getBatchDetails(printIdOrBatchNo: string | undefined): Observable<BatchDetailDto> {
        let url_ = this.baseUrl + "/api/app/batch/getBatchDetails?";
        if (printIdOrBatchNo === null)
            throw new Error("The parameter 'printIdOrBatchNo' cannot be null.");
        else if (printIdOrBatchNo !== undefined)
            url_ += "printIdOrBatchNo=" + encodeURIComponent("" + printIdOrBatchNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processGetBatchDetails(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetBatchDetails(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BatchDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BatchDetailDto>;
        }));
    }

    protected processGetBatchDetails(response: HttpResponseBase): Observable<BatchDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BatchDetailDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param brand (optional) 品牌
     * @return Success
     */
    getBatchLimit(brand: string | undefined): Observable<BatchLimitDto> {
        let url_ = this.baseUrl + "/api/app/batch/getBatchLimit?";
        if (brand === null)
            throw new Error("The parameter 'brand' cannot be null.");
        else if (brand !== undefined)
            url_ += "Brand=" + encodeURIComponent("" + brand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processGetBatchLimit(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetBatchLimit(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BatchLimitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BatchLimitDto>;
        }));
    }

    protected processGetBatchLimit(response: HttpResponseBase): Observable<BatchLimitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BatchLimitDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: CreateBatchDto | undefined): Observable<BatchDto> {
        let url_ = this.baseUrl + "/api/app/batch/insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processInsert(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processInsert(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BatchDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BatchDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<BatchDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BatchDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateBatchDto | undefined): Observable<BatchDto> {
        let url_ = this.baseUrl + "/api/app/batch/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BatchDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BatchDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<BatchDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BatchDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertOrUpdate(body: CreateBatchDto | undefined): Observable<BatchDto> {
        let url_ = this.baseUrl + "/api/app/batch/insertOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processInsertOrUpdate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processInsertOrUpdate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BatchDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BatchDto>;
        }));
    }

    protected processInsertOrUpdate(response: HttpResponseBase): Observable<BatchDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BatchDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/app/batch/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processDelete(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDelete(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<BatchDto> {
        let url_ = this.baseUrl + "/api/app/batch/get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processGet(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGet(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BatchDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BatchDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<BatchDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BatchDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    list(body: GetBatchListInput | undefined): Observable<BatchDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/app/batch/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processList(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processList(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BatchDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BatchDtoPagedResultDto>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<BatchDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BatchDtoPagedResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class Client extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    /**
     * 预览
     * @return Success
     */
    preview(printId: string): Observable<void> {
        let url_ = this.baseUrl + "/preview/{printId}";
        if (printId === undefined || printId === null)
            throw new Error("The parameter 'printId' must be defined.");
        url_ = url_.replace("{printId}", encodeURIComponent("" + printId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processPreview(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPreview(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPreview(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Index
     * @return Success
     */
    index(): Observable<void> {
        let url_ = this.baseUrl + "/";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processIndex(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processIndex(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processIndex(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CodeGenerateClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    /**
     * @return Success
     */
    getEntities(): Observable<string> {
        let url_ = this.baseUrl + "/api/CodeGenerate/GetEntities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processGetEntities(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetEntities(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetEntities(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    generate(body: GenerateInput | undefined): Observable<GenerateInput> {
        let url_ = this.baseUrl + "/api/CodeGenerate/Generate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processGenerate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGenerate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenerateInput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenerateInput>;
        }));
    }

    protected processGenerate(response: HttpResponseBase): Observable<GenerateInput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GenerateInput;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class FileClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    /**
     * upload
     * @param file (optional) 
     * @return Success
     */
    upload(file: FileParameter | undefined): Observable<UploadResult> {
        let url_ = this.baseUrl + "/api/File/Upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processUpload(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUpload(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UploadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UploadResult>;
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<UploadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UploadResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class IdentityClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    /**
     * 获取用户信息
     * @return Success
     */
    getUserInfo(): Observable<IdentityModel> {
        let url_ = this.baseUrl + "/api/Identity/GetUserInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processGetUserInfo(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetUserInfo(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdentityModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdentityModel>;
        }));
    }

    protected processGetUserInfo(response: HttpResponseBase): Observable<IdentityModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdentityModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    permissions(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Identity/Permissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processPermissions(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPermissions(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processPermissions(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class IndexClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    /**
     * 安装系统
     * @param userName (optional) 
     * @param password (optional) 
     * @return Success
     */
    setup(userName: string | undefined, password: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Index/Setup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (userName === null || userName === undefined)
            throw new Error("The parameter 'userName' cannot be null.");
        else
            content_.append("userName", userName.toString());
        if (password === null || password === undefined)
            throw new Error("The parameter 'password' cannot be null.");
        else
            content_.append("password", password.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processSetup(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processSetup(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processSetup(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OuClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    /**
     * 获取所有组织
     * @return Success
     */
    getAll(): Observable<OuDto[]> {
        let url_ = this.baseUrl + "/api/app/ou/getAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processGetAll(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAll(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OuDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OuDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<OuDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OuDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 获取列表
     * @param body (optional) 
     * @return Success
     */
    list(body: GetOuListInput | undefined): Observable<OuDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/app/ou/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processList(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processList(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OuDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OuDtoPagedResultDto>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<OuDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OuDtoPagedResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: CreateOuDto | undefined): Observable<OuDto> {
        let url_ = this.baseUrl + "/api/app/ou/insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processInsert(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processInsert(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OuDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OuDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<OuDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OuDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateOuDto | undefined): Observable<OuDto> {
        let url_ = this.baseUrl + "/api/app/ou/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OuDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OuDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<OuDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OuDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertOrUpdate(body: CreateOuDto | undefined): Observable<OuDto> {
        let url_ = this.baseUrl + "/api/app/ou/insertOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processInsertOrUpdate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processInsertOrUpdate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OuDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OuDto>;
        }));
    }

    protected processInsertOrUpdate(response: HttpResponseBase): Observable<OuDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OuDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/app/ou/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processDelete(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDelete(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<OuDto> {
        let url_ = this.baseUrl + "/api/app/ou/get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processGet(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGet(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OuDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OuDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<OuDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OuDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class PhysicsClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    /**
     * @param batchId (optional) 标牌Id
     * @param physicsId (optional) 物理Id
     * @return Success
     */
    delete(batchId: string | undefined, physicsId: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/app/physics/delete?";
        if (batchId === null)
            throw new Error("The parameter 'batchId' cannot be null.");
        else if (batchId !== undefined)
            url_ += "BatchId=" + encodeURIComponent("" + batchId) + "&";
        if (physicsId === null)
            throw new Error("The parameter 'physicsId' cannot be null.");
        else if (physicsId !== undefined)
            url_ += "PhysicsId=" + encodeURIComponent("" + physicsId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processDelete(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDelete(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertByClient(body: CreatePhysicsByClientDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/app/physics/insertByClient";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processInsertByClient(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processInsertByClient(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInsertByClient(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: CreatePhysicsDto | undefined): Observable<PhysicsDto> {
        let url_ = this.baseUrl + "/api/app/physics/insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processInsert(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processInsert(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PhysicsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PhysicsDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<PhysicsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PhysicsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdatePhysicsDto | undefined): Observable<PhysicsDto> {
        let url_ = this.baseUrl + "/api/app/physics/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PhysicsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PhysicsDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PhysicsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PhysicsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertOrUpdate(body: CreatePhysicsDto | undefined): Observable<PhysicsDto> {
        let url_ = this.baseUrl + "/api/app/physics/insertOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processInsertOrUpdate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processInsertOrUpdate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PhysicsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PhysicsDto>;
        }));
    }

    protected processInsertOrUpdate(response: HttpResponseBase): Observable<PhysicsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PhysicsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param batchId (optional) 标牌Id
     * @param physicsId (optional) 物理Id
     * @return Success
     */
    get(batchId: string | undefined, physicsId: string | undefined): Observable<PhysicsDto> {
        let url_ = this.baseUrl + "/api/app/physics/get?";
        if (batchId === null)
            throw new Error("The parameter 'batchId' cannot be null.");
        else if (batchId !== undefined)
            url_ += "BatchId=" + encodeURIComponent("" + batchId) + "&";
        if (physicsId === null)
            throw new Error("The parameter 'physicsId' cannot be null.");
        else if (physicsId !== undefined)
            url_ += "PhysicsId=" + encodeURIComponent("" + physicsId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processGet(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGet(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PhysicsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PhysicsDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PhysicsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PhysicsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    list(body: GetPhysicsListInput | undefined): Observable<PhysicsDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/app/physics/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processList(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processList(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PhysicsDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PhysicsDtoPagedResultDto>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<PhysicsDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PhysicsDtoPagedResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class PrintClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertOrUpdate(body: CreatePrintDto | undefined): Observable<PrintDto> {
        let url_ = this.baseUrl + "/api/app/print/insertOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processInsertOrUpdate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processInsertOrUpdate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrintDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrintDto>;
        }));
    }

    protected processInsertOrUpdate(response: HttpResponseBase): Observable<PrintDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PrintDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param printId (optional) 
     * @return Success
     */
    getPrintData(printId: string | undefined): Observable<PrintModelDto> {
        let url_ = this.baseUrl + "/api/app/print/getPrintData?";
        if (printId === null)
            throw new Error("The parameter 'printId' cannot be null.");
        else if (printId !== undefined)
            url_ += "printId=" + encodeURIComponent("" + printId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processGetPrintData(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetPrintData(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrintModelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrintModelDto>;
        }));
    }

    protected processGetPrintData(response: HttpResponseBase): Observable<PrintModelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PrintModelDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: CreatePrintDto | undefined): Observable<PrintDto> {
        let url_ = this.baseUrl + "/api/app/print/insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processInsert(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processInsert(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrintDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrintDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<PrintDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PrintDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdatePrintDto | undefined): Observable<PrintDto> {
        let url_ = this.baseUrl + "/api/app/print/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrintDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrintDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PrintDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PrintDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/app/print/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processDelete(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDelete(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<PrintDto> {
        let url_ = this.baseUrl + "/api/app/print/get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processGet(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGet(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrintDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrintDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PrintDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PrintDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    list(body: GetPrintListInput | undefined): Observable<PrintDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/app/print/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processList(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processList(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrintDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrintDtoPagedResultDto>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<PrintDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PrintDtoPagedResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class RoleClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    /**
     * 获取全部
     * @return Success
     */
    getAll(): Observable<RoleDto[]> {
        let url_ = this.baseUrl + "/api/app/role/getAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processGetAll(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAll(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoleDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertOrUpdate(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/app/role/insertOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processInsertOrUpdate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processInsertOrUpdate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processInsertOrUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoleDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 获取全部权限
     * @param roleId (optional) 
     * @return Success
     */
    getListPermission(roleId: string | undefined): Observable<PermissionDto[]> {
        let url_ = this.baseUrl + "/api/app/role/getListPermission?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processGetListPermission(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetListPermission(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDto[]>;
        }));
    }

    protected processGetListPermission(response: HttpResponseBase): Observable<PermissionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PermissionDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/app/role/insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processInsert(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processInsert(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoleDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/app/role/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoleDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/app/role/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processDelete(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDelete(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/app/role/get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processGet(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGet(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoleDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    list(body: GetRoleListInput | undefined): Observable<RoleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/app/role/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processList(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processList(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoPagedResultDto>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<RoleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoleDtoPagedResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class TestClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertByClient(body: CreateTestByClientDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/app/test/insertByClient";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processInsertByClient(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processInsertByClient(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInsertByClient(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: CreateTestDto | undefined): Observable<TestDto> {
        let url_ = this.baseUrl + "/api/app/test/insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processInsert(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processInsert(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TestDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TestDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<TestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TestDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateTestDto | undefined): Observable<TestDto> {
        let url_ = this.baseUrl + "/api/app/test/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TestDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TestDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TestDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertOrUpdate(body: CreateTestDto | undefined): Observable<TestDto> {
        let url_ = this.baseUrl + "/api/app/test/insertOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processInsertOrUpdate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processInsertOrUpdate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TestDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TestDto>;
        }));
    }

    protected processInsertOrUpdate(response: HttpResponseBase): Observable<TestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TestDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/app/test/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processDelete(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDelete(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<TestDto> {
        let url_ = this.baseUrl + "/api/app/test/get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processGet(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGet(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TestDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TestDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TestDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    list(body: GetTestListInput | undefined): Observable<TestDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/app/test/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processList(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processList(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TestDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TestDtoPagedResultDto>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<TestDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TestDtoPagedResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    /**
     * 添加用户
     * @param body (optional) 
     * @return Success
     */
    insert(body: CreateUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/app/user/insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processInsert(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processInsert(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * UpdateAsync
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/app/user/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * 获取所有组织
     * @return Success
     */
    getAll(): Observable<UserDto[]> {
        let url_ = this.baseUrl + "/api/app/user/getAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processGetAll(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAll(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertOrUpdate(body: CreateUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/app/user/insertOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processInsertOrUpdate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processInsertOrUpdate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processInsertOrUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/app/user/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processDelete(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDelete(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/app/user/get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processGet(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGet(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    list(body: GetUserListInput | undefined): Observable<UserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/app/user/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.transformResult(url_, response_, (r) => this.processList(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processList(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoPagedResultDto>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<UserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserDtoPagedResultDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

/** 标牌明细 */
export interface BatchDetailDto {
    printDto?: PrintDto;
    batch?: BatchDto;
    test?: TestDto;
    /** 物理信息 */
    physicses?: PhysicsDto[] | undefined;
}

/** 标牌管理 */
export interface BatchDto {
    /** 标牌Id */
    batchId?: string | undefined;
    /** 批号 */
    batchNo?: string | undefined;
    /** 规格 */
    specification?: string | undefined;
    /** 牌号 */
    brand?: string | undefined;
    /** 定尺 */
    length?: number;
    /** 公称质量 */
    weight?: number;
    /** 质检员 */
    quality?: string | undefined;
    /** 计量员 */
    metrologists?: string | undefined;
    /** 创建时间 */
    createTime?: Date;
}

export interface BatchDtoPagedResultDto {
    page?: PageInfo;
    items?: BatchDto[] | undefined;
}

export interface BatchLimitDto {
    c?: BatchLimitRange;
    si?: BatchLimitRange;
    mn?: BatchLimitRange;
    p?: BatchLimitRange;
    s?: BatchLimitRange;
    ceq?: BatchLimitRange;
    rel?: BatchLimitRange;
    rm?: BatchLimitRange;
    rm_ReL?: BatchLimitRange;
    reL_ReL?: BatchLimitRange;
    elongation?: BatchLimitRange;
    forceElongation?: BatchLimitRange;
}

export interface BatchLimitRange {
    /** 最小值 */
    min?: number;
    /** 最大值 */
    max?: number;
}

/** 标牌管理 */
export interface CreateBatchDto {
    /** 标牌Id */
    batchId?: string | undefined;
    /** 批号 */
    batchNo?: string | undefined;
    /** 规格 */
    specification?: string | undefined;
    /** 牌号 */
    brand?: string | undefined;
    /** 定尺 */
    length?: number;
}

/** 创建组织 */
export interface CreateOuDto {
    /** 组织Id */
    ouId?: string | undefined;
    /** 组织名称 */
    name?: string | undefined;
    /** 电话 */
    phone?: string | undefined;
    /** 地址 */
    address?: string | undefined;
    /** 上级Id */
    parentId?: string | undefined;
    ouType?: OuType;
}

export interface CreatePhysicsByClientDto {
    /** 标牌Id */
    batchId?: string | undefined;
    /** 物理Id */
    physicsId?: string | undefined;
    /** 钢种 */
    type?: string | undefined;
    /** 规格 */
    specification?: string | undefined;
    /** 面积 */
    area?: string | undefined;
    /** 标距长度 */
    length?: string | undefined;
    /** 屈服点负荷N */
    yieldPointLoad?: number;
    /** 抗拉强度 */
    tensileStrength?: number;
    /** 实测屈服强度ReL */
    reL?: number;
    /** 实测抗拉强度Rm */
    rm?: number;
    /** 实测强屈比Rm/ReL */
    rm_ReL?: number;
    /** ReL/ReL */
    reL_ReL?: number;
    /** 断后伸长率 */
    elongation?: number;
    /** 最大力总伸长率 */
    forceElongation?: number;
    /** 冷弯试验 */
    coldBendingTest?: string | undefined;
    /** 批次号 */
    batchNo: string;
}

/** 物理 */
export interface CreatePhysicsDto {
    /** 标牌Id */
    batchId?: string | undefined;
    /** 物理Id */
    physicsId?: string | undefined;
    /** 钢种 */
    type?: string | undefined;
    /** 规格 */
    specification?: string | undefined;
    /** 面积 */
    area?: string | undefined;
    /** 标距长度 */
    length?: string | undefined;
    /** 屈服点负荷N */
    yieldPointLoad?: number;
    /** 抗拉强度 */
    tensileStrength?: number;
    /** 实测屈服强度ReL */
    reL?: number;
    /** 实测抗拉强度Rm */
    rm?: number;
    /** 实测强屈比Rm/ReL */
    rm_ReL?: number;
    /** ReL/ReL */
    reL_ReL?: number;
    /** 断后伸长率 */
    elongation?: number;
    /** 最大力总伸长率 */
    forceElongation?: number;
    /** 冷弯试验 */
    coldBendingTest?: string | undefined;
}

/** 打印 */
export interface CreatePrintDto {
    /** 打印Id */
    printId?: string | undefined;
    /** 标牌Id */
    batchId?: string | undefined;
    /** 支数 */
    count?: number;
    /** 公称质量 */
    weight?: number;
    /** 质检员 */
    quality?: string | undefined;
    /** 计量员 */
    metrologists?: string | undefined;
    /** 定尺 */
    length?: number;
}

export interface CreateTestByClientDto {
    /** 碳 */
    c?: number;
    /** 锰 */
    mn?: number;
    /** 硅 */
    si?: number;
    /** 磷 */
    p?: number;
    /** 硫 */
    s?: number;
    /** 铬 */
    cr?: number;
    /** 镍 */
    ni?: number;
    /** 钼 */
    mo?: number;
    /** 铜 */
    cu?: number;
    /** 钒 */
    v?: number;
    /** 标牌Id */
    batchId?: string | undefined;
    /** 批次号 */
    batchNo?: string | undefined;
}

/** 化学 */
export interface CreateTestDto {
    /** 碳 */
    c?: number;
    /** 锰 */
    mn?: number;
    /** 硅 */
    si?: number;
    /** 磷 */
    p?: number;
    /** 硫 */
    s?: number;
    /** 铬 */
    cr?: number;
    /** 镍 */
    ni?: number;
    /** 钼 */
    mo?: number;
    /** 铜 */
    cu?: number;
    /** 钒 */
    v?: number;
    /** 标牌Id */
    batchId?: string | undefined;
}

/** CreateUserDto */
export interface CreateUserDto {
    /** 用户Id */
    userId?: string | undefined;
    /** 用户名 */
    userName?: string | undefined;
    /** 姓名 */
    name?: string | undefined;
    /** 手机号码 */
    phoneNumber?: string | undefined;
    /** 身份证号 */
    idNo?: string | undefined;
    userType?: UserType;
    /** 党员类型 */
    readonly userTypeDesc?: string | undefined;
    /** 组织Id */
    ouId?: string | undefined;
    /** 职务 */
    position?: string | undefined;
    positionType?: PositionType;
    /** 职务 */
    readonly positionTypeDesc?: string | undefined;
    /** 角色 */
    roles?: string[] | undefined;
    /** 密码 */
    password?: string | undefined;
}

export interface GenerateInput {
    name: string;
    readonly camelCaseName?: string | undefined;
    displayName?: string | undefined;
    moduleName?: string | undefined;
    moduleDisplayName?: string | undefined;
    namespace?: string | undefined;
    fields?: ModelField[] | undefined;
}

/** 标牌管理 */
export interface GetBatchListInput {
    /** 批号 */
    batchNo?: string | undefined;
    page?: PageInfo;
    /** 排序 */
    sorting?: string | undefined;
}

export interface GetOuListInput {
    /** 上级Id */
    parentId?: string | undefined;
    page?: PageInfo;
}

/** 物理 */
export interface GetPhysicsListInput {
    /** 标牌Id */
    batchId: string;
    page?: PageInfo;
    /** 排序 */
    sorting?: string | undefined;
}

/** 打印 */
export interface GetPrintListInput {
    /** 批次Id */
    batchId: string;
    page?: PageInfo;
    /** 排序 */
    sorting?: string | undefined;
}

/** GetRoleListInput */
export interface GetRoleListInput {
    page?: PageInfo;
}

/** 化学 */
export interface GetTestListInput {
    /** 标牌Id */
    batchId: string;
    page?: PageInfo;
    /** 排序 */
    sorting?: string | undefined;
}

/** GetUserListInput */
export interface GetUserListInput {
    /** 用户名 */
    userName?: string | undefined;
    page?: PageInfo;
    /** 分页 */
    sorting?: string | undefined;
}

/** 用户信息 */
export interface IdentityModel {
    /** 用户Id */
    userId?: string | undefined;
    /** 用户名 */
    userName?: string | undefined;
    /** 姓名 */
    name?: string | undefined;
    /** 组织Id */
    ouId?: string | undefined;
    /** 是否超管 */
    isSpecial?: boolean;
    positionType?: PositionType;
}

/** 登录模型 */
export interface LoginModel {
    /** 用户名 */
    userName?: string | undefined;
    /** 密码 */
    password?: string | undefined;
    /** 记住我 */
    isPersistent?: boolean;
}

export interface LoginResult {
    /** token */
    accessToken?: string | undefined;
    /** 过期时间 */
    expireIn?: number;
}

export interface ModelField {
    name?: string | undefined;
    readonly camelCaseName?: string | undefined;
    displayName?: string | undefined;
    type?: string | undefined;
    isPrimaryKey?: boolean;
    canBeNull?: boolean;
    isQuery?: boolean;
    isDto?: boolean;
    isCreate?: boolean;
    isUpdate?: boolean;
}

/** 组织Dto */
export interface OuDto {
    /** 组织Id */
    ouId?: string | undefined;
    /** Id */
    readonly id?: string | undefined;
    /** 组织名称 */
    name?: string | undefined;
    /** 电话 */
    phone?: string | undefined;
    /** 地址 */
    address?: string | undefined;
    /** 上级Id */
    parentId?: string | undefined;
    ouType?: OuType;
    /** 组织级别 */
    readonly ouTypeDesc?: string | undefined;
    /** 子列表 */
    children?: OuDto[] | undefined;
}

export interface OuDtoPagedResultDto {
    page?: PageInfo;
    items?: OuDto[] | undefined;
}

export enum OuType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export interface PageInfo {
    pageIndex?: number;
    pageSize?: number;
    totalCount?: number;
    totalPage?: number;
}

export interface PermissionDto {
    /** 名称 */
    name?: string | undefined;
    /** 显示名称 */
    displayName?: string | undefined;
    /** 父级名称 */
    parent?: string | undefined;
    /** 是否选中 */
    isSelected?: boolean;
}

/** 物理 */
export interface PhysicsDto {
    /** 标牌Id */
    batchId?: string | undefined;
    /** 物理Id */
    physicsId?: string | undefined;
    /** 钢种 */
    type?: string | undefined;
    /** 规格 */
    specification?: string | undefined;
    /** 面积 */
    area?: string | undefined;
    /** 标距长度 */
    length?: string | undefined;
    /** 屈服点负荷N */
    yieldPointLoad?: number;
    /** 抗拉强度 */
    tensileStrength?: number;
    /** 实测屈服强度ReL */
    reL?: number;
    /** 实测抗拉强度Rm */
    rm?: number;
    /** 实测强屈比Rm/ReL */
    rm_ReL?: number;
    /** ReL/ReL */
    reL_ReL?: number;
    /** 断后伸长率 */
    elongation?: number;
    /** 最大力总伸长率 */
    forceElongation?: number;
    /** 冷弯试验 */
    coldBendingTest?: string | undefined;
}

export interface PhysicsDtoPagedResultDto {
    page?: PageInfo;
    items?: PhysicsDto[] | undefined;
}

export enum PositionType {
    _0 = 0,
    _1 = 1,
}

/** 打印 */
export interface PrintDto {
    /** 打印Id */
    printId?: string | undefined;
    /** 标牌Id */
    batchId?: string | undefined;
    /** 支数 */
    count?: number;
    /** 公称质量 */
    weight?: number;
    /** 质检员 */
    quality?: string | undefined;
    /** 计量员 */
    metrologists?: string | undefined;
    /** 创建时间 */
    createTime?: Date;
}

export interface PrintDtoPagedResultDto {
    page?: PageInfo;
    items?: PrintDto[] | undefined;
}

/** 打印数据模型 */
export interface PrintModelDto {
    /** Json */
    json?: string | undefined;
    /** 数据 */
    data?: string | undefined;
}

/** 角色 */
export interface RoleDto {
    /** 角色Id */
    roleId?: string | undefined;
    /** 角色名称 */
    name?: string | undefined;
    /** 角色描述 */
    description?: string | undefined;
    /** 角色权限 */
    rolePermissions?: string[] | undefined;
}

export interface RoleDtoPagedResultDto {
    page?: PageInfo;
    items?: RoleDto[] | undefined;
}

/** 化学 */
export interface TestDto {
    /** 碳 */
    c?: number;
    /** 锰 */
    mn?: number;
    /** 硅 */
    si?: number;
    /** 磷 */
    p?: number;
    /** 硫 */
    s?: number;
    /** 铬 */
    cr?: number;
    /** 镍 */
    ni?: number;
    /** 钼 */
    mo?: number;
    /** 铜 */
    cu?: number;
    /** 钒 */
    v?: number;
    /** Ceq */
    ceq?: number;
    /** 标牌Id */
    batchId?: string | undefined;
}

export interface TestDtoPagedResultDto {
    page?: PageInfo;
    items?: TestDto[] | undefined;
}

/** 标牌管理 */
export interface UpdateBatchDto {
    /** 标牌Id */
    batchId?: string | undefined;
    /** 批号 */
    batchNo?: string | undefined;
    /** 规格 */
    specification?: string | undefined;
    /** 牌号 */
    brand?: string | undefined;
    /** 定尺 */
    length?: number;
}

/** 物理 */
export interface UpdatePhysicsDto {
    /** 标牌Id */
    batchId?: string | undefined;
    /** 物理Id */
    physicsId?: string | undefined;
    /** 钢种 */
    type?: string | undefined;
    /** 规格 */
    specification?: string | undefined;
    /** 面积 */
    area?: string | undefined;
    /** 标距长度 */
    length?: string | undefined;
    /** 屈服点负荷N */
    yieldPointLoad?: number;
    /** 抗拉强度 */
    tensileStrength?: number;
    /** 实测屈服强度ReL */
    reL?: number;
    /** 实测抗拉强度Rm */
    rm?: number;
    /** 实测强屈比Rm/ReL */
    rm_ReL?: number;
    /** ReL/ReL */
    reL_ReL?: number;
    /** 断后伸长率 */
    elongation?: number;
    /** 最大力总伸长率 */
    forceElongation?: number;
    /** 冷弯试验 */
    coldBendingTest?: string | undefined;
}

/** 打印 */
export interface UpdatePrintDto {
    /** 打印Id */
    printId?: string | undefined;
    /** 标牌Id */
    batchId?: string | undefined;
    /** 支数 */
    count?: number;
    /** 公称质量 */
    weight?: number;
    /** 质检员 */
    quality?: string | undefined;
    /** 计量员 */
    metrologists?: string | undefined;
}

/** 化学 */
export interface UpdateTestDto {
    /** 碳 */
    c?: number;
    /** 锰 */
    mn?: number;
    /** 硅 */
    si?: number;
    /** 磷 */
    p?: number;
    /** 硫 */
    s?: number;
    /** 铬 */
    cr?: number;
    /** 镍 */
    ni?: number;
    /** 钼 */
    mo?: number;
    /** 铜 */
    cu?: number;
    /** 钒 */
    v?: number;
    /** 标牌Id */
    batchId?: string | undefined;
}

export interface UpdateUserDto {
    /** 用户Id */
    userId?: string | undefined;
    /** 用户名 */
    userName?: string | undefined;
    /** 姓名 */
    name?: string | undefined;
    /** 手机号码 */
    phoneNumber?: string | undefined;
    /** 密码 */
    password?: string | undefined;
    /** 身份证号 */
    idNo?: string | undefined;
    userType?: UserType;
    /** 党员类型 */
    readonly userTypeDesc?: string | undefined;
    /** 组织Id */
    ouId?: string | undefined;
    /** 职务 */
    position?: string | undefined;
    positionType?: PositionType;
    /** 职务 */
    readonly positionTypeDesc?: string | undefined;
    /** 角色 */
    roles?: string[] | undefined;
}

/** FileResult */
export interface UploadResult {
    /** 文件地址 */
    url?: string | undefined;
}

export interface UserDto {
    /** 用户Id */
    userId?: string | undefined;
    /** 用户名 */
    userName?: string | undefined;
    /** 姓名 */
    name?: string | undefined;
    /** 手机号码 */
    phoneNumber?: string | undefined;
    /** 身份证号 */
    idNo?: string | undefined;
    userType?: UserType;
    /** 党员类型 */
    readonly userTypeDesc?: string | undefined;
    /** 组织Id */
    ouId?: string | undefined;
    /** 职务 */
    position?: string | undefined;
    positionType?: PositionType;
    /** 职务 */
    readonly positionTypeDesc?: string | undefined;
    /** 角色 */
    roles?: string[] | undefined;
}

export interface UserDtoPagedResultDto {
    page?: PageInfo;
    items?: UserDto[] | undefined;
}

export enum UserType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}